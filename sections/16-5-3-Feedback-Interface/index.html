<h2>5.3 - Feedback Interface</h2>
<p><img src="images/case-study/feedback-interface.png" alt="Campfire architecture with feedback interface and ALB highlighted"></p>
<p>Campfire wanted to design a feedback interface that accomplishes a few things:</p>
<ul>
<li>integrates with the deploy preview, so that stakeholders don’t need to switch contexts to add feedback</li>
<li>handles comments, since this is the main way stakeholders can leave feedback</li>
<li>allows the user to capture context, for when text comments alone aren’t enough</li>
</ul>
<p>We’ll be talking more about why and how we implemented these in the next few sections, as well as a few challenges we encountered along the way. Finally, we’ll end with a brief section on our backend infrastructure.</p>
<h3>5.3.1 - Integrating the Deploy Preview with the Feedback Interface</h3>
<p><img src="images/case-study/integrating-fi.gif" alt="GIF of feedback interface and deploy preview coming together"></p>
<p>When it came to integrating our feedback interface with our deploy preview, we had two options:</p>
<ol>
<li>Inject or ask the user to add the feedback interface to their application – perhaps as a custom web component, script, or using an iframe.</li>
<li>Create a feedback interface application that embeds the deploy preview within it using an iframe.</li>
</ol>
<p><img src="images/case-study/integration-options.png" alt="Feedback interface in deploy preview vs deploy preview in feedback interface"></p>
<p>The first option would require only one running task (the deploy preview) since the feedback interface would not be a separate component. This could reduce costs, since if there are no active preview deploys, there would also be no running feedback interface. However, it adds an extra step for the user, and we would potentially limit the type of supported applications, since compatibility with different frontend frameworks would have to be managed.</p>
<p>Since the second option would not require any additional work on the user’s part and would maximize on application compatibility, we decided to create a separate feedback interface that would embed the deploy preview. We built a React application with an iframe that points to the deploy preview.</p>
<p>This meant that everytime we deployed a preview app, we actually had to generate two URLs: one that pointed to the deploy preview itself, and one that pointed to the feedback interface.</p>
<table>
  <tr>
   <td><strong>Component</strong>
   </td>
   <td><strong>URL</strong>
   </td>
  </tr>
  <tr>
   <td>Deploy Preview
   </td>
   <td>client-app-12.preview.campfire.com
   </td>
  </tr>
  <tr>
   <td>Feedback Interface
   </td>
   <td>feedback-interface.campfire.com/client-app/12
   </td>
  </tr>
</table>
<p>The user would be given the URL that pointed to the feedback interface, while the URL generated for the deploy preview would be used internally by the feedback interface application.</p>
<p><em>[insert graphic that shows:</em></p>
<ol>
<li><em>Spinning up deploy preview</em></li>
<li><em>Getting link for deploy preview</em></li>
<li><em>Embedding deploy preview into feedback interface with iframe</em></li>
<li><em>Iframe using the link to the deploy preview</em></li>
<li><em>Link to feedback interface given to the user</em></li>
</ol>
<p><em>]</em></p>
<h3>5.3.2 - Comments</h3>
<p>Comments allow all stakeholders, including those without technical expertise or a GitHub account, to actively participate in the deployment review process enabling detailed feedback and discussions directly within deploy previews. Comments allow teams to discuss issues and suggest improvements, fostering an interactive and collaborative review environment.</p>
<p>We designed Campfire to aggregate comments in both the GitHub interface and within the deploy preview itself. This dual visibility ensures that feedback is not lost across platforms and supports a unified discussion thread that all team members can follow and contribute to, regardless of where they choose to interact.</p>
<p>To accomplish this, we needed to retrieve existing comments from GitHub pull requests and also enable the posting of new comments from within Campfire. The implementation of this commenting functionality involved use of GitHub’s API.</p>
<p>GitHub has three options to authorize API requests, although this can be reduced to less than three depending on the API resource being accessed. For Campfire to obtain the necessary authorization in order to push comments from Campfire back to the GitHub pull request we could use:</p>
<ul>
<li>A Personal Access Token (requires GitHub account),</li>
<li>A User Access Token (requires GitHub account), or</li>
<li>An App Installation Token</li>
</ul>
<p>Recognizing that not all Campfire users would have a GitHub account, we chose to utilize GitHub’s App Installation Token for authorization. This approach allows Campfire to post comments on behalf of users, thereby allowing feedback added to Campfire to sync with the pull request while also enabling users who are not registered on GitHub to contribute their own feedback.</p>
<p>Generating this token requires the user or organization using Campfire to register and install a GitHub App with configured permissions. Once the app is installed, Campfire is able to generate the required authorization through its credentials and cross-posts any comments made in Campfire directly to the pull request.</p>
<p>To avoid exposing sensitive data from the feedback interface, the GitHub App’s credentials were stored in AWS Secrets Manager. Any GitHub-related actions taken requires retrieving these credentials beforehand to authenticate the GitHub App. The following diagram shows the flow for posting comments:</p>
<p><img src="images/case-study/comments-flow.png" alt="Architecture/flow for posting comment"></p>
<p>Adding authorization to our requests also benefited our GET requests by increasing the rate limits and allowing GET requests to private repos.</p>
<p>Using our GitHub app to authorize POST requests to the API, however, also meant that all Campfire user’s comments would be attributed to the App and not the individuals themselves who were leaving feedback:</p>
<p><img src="images/case-study/campfire-bot-comment.png" alt="GitHub Bot commenting 'This looks great&quot;!'"></p>
<p>To get around this issue, Campfire displays a welcome screen for first time users before they are able to view the deploy preview. The name the user enters is then stored in their browser’s local storage, ready for use on subsequent visits. The user’s name is also displayed in the top right corner of the feedback interface and prefixed to any comments they make through Campfire.</p>
<p><img src="images/case-study/welcome-name.png" alt="Prompt the user for name"></p>
<p>The welcome screen asks the user for their name before they can interact with the deploy preview.</p>
<p><img src="images/case-study/name-banner.png" alt="Name banner in feedback interface"></p>
<p>Once they enter their name it’s displayed in the top right.</p>
<p><img src="images/case-study/name-banner-collapsed.png" alt="Name banner in feedback interface hidden"></p>
<p>The tab is collapsible so it’s not in the way.</p>
<p>Comments can now be attributed to the right user:
<img src="images/case-study/comment-with-name.png" alt="GitHub comment in pull request with user's name"></p>
<p>Other context Campfire provides includes some basic information on the user’s operating system, browser, and screen-size appended to comments. It may be the case that the UI breaks in certain browsers, but not others, or when viewed at certain dimensions. Having the user’s browser stack info enables the engineering team to more easily replicate the conditions that lead to issues, thereby fixing any bugs much faster.</p>
<h3>5.3.3 - Exploring Screen Capture Solutions</h3>
<p>Our team investigated enhancing the Campfire feedback interface with screen capture functionality to provide richer context for debugging and user support. The goal was to record interactions to quickly identify and address issues encountered by developers or users.</p>
<p>There are a few different approaches to capturing user interactions:</p>
<ul>
<li><strong>Screenshots</strong> - Capture a single moment, useful for documenting specific issues.</li>
<li><strong>Screen recordings</strong> - Record a sequence of actions, providing a video-like overview of user interactions.</li>
<li><strong>Session replay</strong> - Record all DOM events to create a detailed playback of user interactions, offering comprehensive insights into user behaviors and issues.</li>
</ul>
<p>Initially, we researched the SDKs of third-party tools such as Loom and Zight, which offer screen recording and screenshot capabilities. We decided to not use these solutions given that they’re not open-source or self-hosted, which doesn’t align with Campfire’s open-source design.</p>
<p>Although screenshots and screen-recording provide visual context, we sought a more detailed capture of user interactions. Ideally any captured data should be useful for developers seeking to understand and accurately replicate issues users face. This led us to prioritizing implementing a session replay feature, which records DOM events in detail, facilitating a deeper analysis and easier replication of issues by developers.</p>
<p>Session replay captures DOM events such as mouse movements, clicks, scrolls, keystrokes, and changes within the DOM. These events are stored in an array, and replay involves reconstructing the user session from these events. This method not only allows skipping periods of inactivity, enhancing storage efficiency, but also structures data in a way conducive to further analytics.</p>
<p>Conversely, screen recordings provide a continuous video capture of the user's screen, which can include elements outside the webpage context, like video streams and browser extensions. Screen recordings can also effortlessly capture content within iframes, a task challenging for session replay due to security and technical limitations.</p>
<p>While screen recordings capture more visual information, they lack the parsability and storage efficiency of session replays. Session replays, recording only meaningful DOM interactions, avoid unnecessary data accumulation during inactivity and structure data for potential analytical use, unlike the less-structured nature of video files.</p>
<p>After evaluating these options, we concluded that session replay offered the most advantages for Campfire's needs, aligning with our goal of providing actionable insights into user behavior while maintaining efficient data management.</p>
<h3>5.3.4 - Implementing Session Replay and SDK</h3>
<p>Choosing to implement a session replay feature was not without its complications. Because a session replay is by default not able to record events occurring within an iframe, we had some additional work ahead of us.</p>
<p>We chose the rrweb library to implement this feature due to its ease of use and open-source nature. Cross-origin policies and browser security measures prohibit session replay libraries such as rrweb from accessing the contents of an iframe that are hosted on different domains. For Campfire, this meant we were unable to record interactions from the client’s application because the deploy preview domain and feedback interface domain were not the same.</p>
<p><img src="images/case-study/blank-screen-recording.gif" alt="GIF of session replay being blank"></p>
<p><em>^ session replay not working and only showing a blank screen</em></p>
<p>In situations where developers have ownership of both the parent application and the child application, rrweb recommends embedding their library components into both applications. All recorded user interactions in the child application can then be sent to the parent application.</p>
<p>The diagram below illustrates this solution in terms of Campfire’s use-case. Here the feedback interface is the parent application and the deploy preview (preview app) is the child application.</p>
<p><img src="images/case-study/embedding-rrweb.png" alt="rrweb in client app communicating with rrweb in feedback interface"></p>
<p>Implementing rrweb's solution to successfully display iframes in recordings required having rrweb’s component embedded in the client application. This presented an additional prerequisite for the user: the rrweb component (or an SDK) must be embedded into the application in order for the session replay feature to function properly. We initially dismissed this option as one of our priorities in developing Campfire was to have as few prerequisites for our users as possible.</p>
<p>The second option to rrweb’s solution was to programmatically inject the rrweb component into the embedded application. This removed the prerequisite for users to manually embed the component themselves. However, this idea was later deemed unviable due to security measures enforced by browsers. The same cross-origin policies that restricted rrweb from directly recording iframes also restricted the parent application from accessing the contents of the iframe.This meant the feedback interface could not manipulate the DOM of the iframe and inject the rrweb component.</p>
<p>The third option was for the client application to use special response headers when being retrieved from the feedback interface. In the HTTP request/response lifecycle, the Content-Security-Policy response header can be used to authorize certain origins to access the requested resource, in this case the client application, within iframes. This meant the feedback interface could be whitelisted and allowed to manipulate the DOM of the embedded client application.</p>
<p>While this approach appeared to be a practical solution, using special response headers would require additional AWS services to append the response heads to resources. AWS’s Application Load Balancer does not provide a mechanism for adding response headers. AWS Cloudfront, on the other hand, provides the capabilities to do so. To avoid adding additional complexity to our AWS infrastructure, we did not choose this approach.</p>
<p>After considering our possible solutions and their tradeoffs, we decided the simplest approach would be to create our own SDK and require clients to embed the SDK into their applications. The SDK abstracts away the rrweb library component and is responsible for transmitting recorded user interactions back to the feedback interface.</p>
<p><img src="images/case-study/rrweb-sdk.png" alt="Feedback interface communicating with embedded Campfire SDK"></p>
<p>Although the SDK adds an additional prerequisite for our users, we believed it was the most straightforward option for our first iteration of Campfire. An advantage of building an SDK is we can continue to build onto the SDK in the future to add new features to the feedback interface. Features that we had previously decided against due to the lack of inter-iframe communication can now be implemented with the addition of the SDK.</p>
<h3>5.3.6 - Handling Ad Blocker Interference</h3>
<p>After incorporating the rrweb library for session replay into our Campfire application, we encountered another issue: the entire Campfire app failed to load for users with ad-blocking extensions active in their browsers. This problem was traced back to rrweb being integrated into several of our React components, which are interconnected. When rrweb was blocked by an ad blocker, it led to a cascading failure, preventing the entire application from loading, not just the session replay feature.</p>
<p>To address this, instead of identifying and managing individual ad-blocking extensions, we focused on detecting whether the rrweb functionality was obstructed. If rrweb failed to load, we implemented a system to inform the user through a notification banner, advising them to disable their ad blocker to access Campfire.</p>
<p>Implementing this solution involved exploring dynamic component and module loading in React. By adopting dynamic imports, we were able to conditionally load rrweb components, ensuring that even if these components failed to load due to an ad blocker, the rest of the application would remain functional. This approach also allowed us to display a banner alerting users of the need to disable their ad blockers.</p>
<h3>5.3.7 - Serverless Backend</h3>
<p>At this point, Campfire needed a backend to use GitHub’s API and to use the AWS SDK. Authenticated calls to GitHub's API were for retrieving and posting comments to pull requests, while the AWS SDK was needed to store user generated session replay data.</p>
<p>Initially two approaches were considered for our backend infrastructure:</p>
<ul>
<li>traditional server-based backend</li>
<li>a serverless architecture</li>
</ul>
<p>We opted for a serverless approach using AWS Lambda, a computing service that allows you to execute code without provisioning or managing servers. Using an API Gateway with Lambda integration did not require an additional service to be hosted for the backend. However, it did require the incorporation of several new resources, primarily the API Gateway and Lambda functions. While this choice added additional complexity to Campfire’s architecture, the services we chose to use are far less expensive than having multiple ECS services running on a cluster on the user’s account.</p>
<p>A traditional backend setup would involve using a server, for example an Express application, paired with a web server, like Nginx, to manage API routing. This type of set-up would have the benefit of avoiding cold starts that are the result of using a serverless architecture. The trade-off is that the user would have to pay the costs of having a server running continuously, even if there are little to no requests being handled. Since deploy previews don’t necessarily need the speed that comes with avoiding cold starts, we thought it best to maximize cost-efficiency.</p>
