<h1>2 - The Problem</h1>
<p>In the early days of web development, software engineers often made live changes directly on production servers, a risky practice that could easily break the website or service.</p>
<p>As the industry matured, developers began adopting version control systems like Git and SVN to better manage and track code changes. However, these systems did not solve the problem of testing changes in a controlled environment before production deployment. <a href="#8---references">1</a> <a href="#8---references">2</a></p>
<p>The rise of agile development and continuous integration/continuous deployment (CI/CD) practices led to the adoption of staging environments. These environments allowed teams to test code in settings that closely mirrored their production environment, enabling them to identify and fix bugs without affecting the live application. Despite the benefits, staging environments introduced significant bottlenecks. Multiple developers often pushed their changes to a single staging environment simultaneously, leading to conflicts and resource contention. This not only caused delays and increased security risks but also led to bugs and higher operational costs. <a href="#8---references">3</a></p>
<p>The process of resolving bugs found in staging involves several structured steps, especially when using tools like GitHub:</p>
<ul>
<li><strong>Branch Creation</strong> - Developers create a new branch from the main codebase, allowing them to address bugs without impacting the stable production version.</li>
<li><strong>Commit Changes</strong> - Necessary fixes are made and committed to the branch, with detailed commit messages explaining the changes.</li>
<li><strong>Push to Repository</strong> - The branch is then pushed to the remote repository on GitHub.</li>
<li><strong>Create Pull Request</strong> - A pull request is opened against the main branch for merging the fixes and facilitating code review.</li>
<li><strong>Code Review and Approval</strong> - The pull request is reviewed by team members who may suggest or request changes.</li>
<li><strong>Merge and Deploy to Staging</strong> - After approval, the changes are merged and deployed to the staging environment to verify the bug fix.</li>
<li><strong>Testing in Staging</strong> - The application is tested in staging to ensure the fix is effective and no new issues have arisen.</li>
<li><strong>Push to Production</strong> - Once confirmed, the changes are deployed to production.</li>
<li><strong>Monitoring</strong> - Post-deployment the application is monitored for any unexpected issues.</li>
</ul>
<p>If bugs are detected during staging tests, the process from branch creation to staging deployment may need to be repeated to ensure all issues are thoroughly addressed. <a href="#8---references">4</a><a href="#8---references">5</a><a href="#8---references">6</a></p>
<p>Historically, non-engineering team members such as UI designers, QA testers, marketers, and product managers had limited opportunities to view and provide feedback on proposed changes until late in the development process. Often, they only saw these changes when they were moved to the staging or production environments.</p>
<p>This delay not only prevented timely feedback that could influence design and functionality but also excluded these key stakeholders from early stages of project discussions. Additionally, the lack of a dedicated feedback mechanism in earlier development stages meant that their insights, which could significantly impact user experience and product success, were often underutilized or solicited too late to make meaningful adjustments without time-consuming revisions. <a href="#8---references">7</a></p>
<p><img src="images/case-study/02.png" alt="Before deploy previews dev cycle"></p>
