<h2>5.1 - Automating Deploy Previews</h2>
<h2></h2>
<p><img src="images/case-study/automation.png" alt="Campfire architecture highlighting automation"></p>
<p>Campfire’s architecture starts with the automatic deployment of deploy previews, which are generated for each pull request and hosted temporarily until the pull request is closed. We faced two primary decisions in this area:</p>
<p>1. How to automatically trigger a deployment when a pull request is made?</p>
<p>2. How to host the client application once deployed?</p>
<h3>5.1.1 Automatically Triggering Deployment</h3>
<p>We initially considered using webhooks to trigger a self-hosted endpoint whenever a pull request was created by the user. However, this required deploying a dedicated service to handle webhook events, which would involve additional resources being provisioned on the user’s AWS account.</p>
<p>We opted instead for GitHub Actions, a CI/CD platform that offers the flexibility of using either self-hosted or GitHub-hosted runners to automate workflows. This approach eliminates the need to manage separate resources for webhook responses. GitHub Actions automatically provisions an environment to execute our defined workflows, which handle tasks such as authenticating cloud services, spinning up the necessary resources for the deploy preview, and posting the preview URL back to the pull request.</p>
<p>Additionally, GitHub Actions manages the lifecycle of the runners, ensuring they shut down and clean up resources after execution. This efficiency and integration led us to choose GitHub Actions for automating the deployment of deploy previews. Consequently, a fundamental requirement for using Campfire is that the user’s application must be hosted on GitHub; therefore, we are currently unable to support users on other platforms like GitLab.</p>
<p><img src="images/case-study/09.gif" alt="Trigger deploy preview using GitHub Actions"></p>
<h3>5.1.2 Hosting the Client’s Application</h3>
<p>The next step involved selecting a service to temporarily host the client application. To accommodate a diverse range of applications and simplify the deployment process, Campfire chose to support containerized applications. Containerization packages an application with its dependencies and configurations into a standardized unit, or container, ensuring it runs consistently across any environment.</p>
<p>Ensuring that the client application behaves the same way locally as it does once deployed minimizes bugs related to cross-platform compatibility issues. By focusing on containerized applications, we enhance the likelihood of successful deployments regardless of the specific setup or technology stack of the application.</p>
<p>The use of containers required a way to manage their life cycles – deploying, updating, and terminating containers as pull requests are opened, updated, or closed. Container orchestration services provide many features in addition to managing the lifecycle of containers, including automated scaling and high availability. Without container orchestration services, manual management of container lifecycles and scaling would be required, introducing complexity and potential for error.</p>
<p>We selected AWS Elastic Container Service (ECS) because it simplifies container orchestration and easily integrates with other AWS services such as the application load balancer used in Campfire. ECS automates the deployment, scaling, and monitoring of containers, allowing us to deliver stable and consistent deploy previews without the burden of managing the orchestration layer ourselves.</p>
<p>While other solutions like Elastic Kubernetes Service (EKS) and Docker Swarm offer more control and flexibility in managing containers, they require deep knowledge of their ecosystems and are feature-rich, which can be excessive for our needs. Given that Campfire requires orchestration for just a single container per pull request, the simpler and less complex ECS is more appropriate than the more powerful but complex alternatives like EKS and Docker Swarm.</p>
