<h2>5.1 - Automating Deploy Previews</h2>
<h2></h2>
<p><img src="images/image11.png" alt="alt_text" title="image_tooltip"></p>
<p>The architecture of our system starts with the automatic deployment of deploy previews, which are generated for each pull request to a repository and hosted temporarily. We faced two primary decisions in this area:</p>
<ol>
<li>
<p>How to automatically trigger a deployment when a pull request is made.</p>
</li>
<li>
<p>How to host the client application once deployed.</p>
</li>
</ol>
<p>We initially considered using webhooks to notify an endpoint whenever a pull request was triggered. However, this required maintaining a dedicated service to handle webhook events, which would involve additional resources.</p>
<p>We opted instead for GitHub Actions, a CI/CD platform that offers the flexibility of using either self-hosted or GitHub-hosted runners to automate workflows. This approach eliminates the need to manage separate resources for webhook responses. GitHub Actions automatically provisions an environment to execute our defined workflows, which handle tasks like authenticating cloud services, spinning up the necessary resources for the deploy preview, and posting the preview URL back to the pull request.</p>
<p>Additionally, GitHub Actions manages the lifecycle of the runners, ensuring they shut down gracefully and clean up resources after execution. This efficiency and integration led us to choose GitHub Actions for automating the deployment of deploy previews.</p>
<p><img src="images/image12.gif" alt="alt_text" title="image_tooltip"></p>
<p>The next step involved selecting a service to temporarily host the client application. In order to accommodate a diverse range of applications and simplify deployment processes, Campfire chose to support containerized applications. Containerization involves packaging an application along with its dependencies and configurations into a standardized unit, or container, that can run consistently across any environment. This approach reduces the complexity of deploying applications because it abstracts the details of the underlying infrastructure.</p>
<p>Containers ensure that the application behaves the same way in development, testing, and production environments, which is critical for reliable deploy previews. By focusing on containerized applications, we ensured that any type of application, regardless of its specific setup or technology stack, can be easily integrated and previewed without extensive customization.</p>
<p>To efficiently manage these containers, especially at scale, container orchestration became a necessary part of our infrastructure. For this purpose, we considered Docker Swarm and Kubernetes, but found their complexity and management requirements excessive for our needs. Campfire requires only one container per pull request, making the lightweight and less complex AWS Elastic Container Service (ECS) a more suitable choice. AWS ECS simplifies container management by automating the deployment, scaling, and monitoring of containers, allowing us to focus on delivering stable and consistent deploy previews without the overhead of managing the orchestration layer ourselves.</p>
<p>Within AWS ECS, we were presented with two launch types: EC2 and Fargate. AWS EC2 offers more control over the underlying instances, but it also requires more management. AWS Fargate, on the other hand, abstracts the underlying server infrastructure, providing a serverless experience that automatically scales and manages the container lifecycle. This choice is particularly suitable for Campfire as it only requires a single container for each application and does not require customized container orchestration.</p>
